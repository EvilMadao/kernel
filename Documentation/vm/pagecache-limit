Functionality:
-------------
The patch introduces a new tunable in the proc filesystem:

/proc/sys/vm/pagecache_limit_mb

This tunable sets a limit to the pagecache in megabytes.
If non-zero, it should not be set below 4 (4MB), or the system might behave erratically. In real-life, much larger limits (a few hundred MB to some GBs) will be useful.

Examples:
echo 1024 >/proc/sys/vm/pagecache_limit_mb

This sets a baseline limits for the page cache (not the buffer cache!) of 1GiB.
NOTE: The real limit depends on the amount of free memory. Every existing free page allows the page cache to grow 16x the amount of free memory above the set baseline. As soon as the free memory is needed, we free up page cache.

This feature only works if CONFIG_HIBERNATION is configured in, as the
needed helpers only exist then.

How it works:
------------
The heart of this patch is a new function called shrink_page_cache(). It is called from balance_pgdat (which is the worker for kswapd) if the pagecache is above the limit.
The function is also called in __alloc_pages_slowpath (if we are above a limit calculated with 1.25x the baseline), and add_to_page_cache so we don't exclusively rely on background shrinking from kswapd.

shrink_page_cache() calculates the nr of pages the cache is over its limit. It reduces this number by a factor (so you have to call it several times to get down to the target) adds vm_pagecache_min_dec (2MB) and then shrinks the pagecache (using the Kernel LRUs).

shrink_page_cache has two modes:
- Just do one pass, reclaiming from inactive pagecache memory.
  This is fast (but might not find free pages). It's used from the alloc path.
- Do 4 passes, with moving pages from active to inactive (pass 1, 3) and also allowing pages to be written out (passes 2, 3).

The function returns the nr of reclaimed pages.


How it changes memory management:
--------------------------------
If the pagecache_limit_mb is set to zero (default), nothing changes.

If set to a positive value, there will be three different operating modes:
(1) If we still have plenty of free pages, the pagecache limit will NOT be enforced. Memory management decisions are taken as normally.
(2) However, as soon someone consumes those free pages, we'll start freeing pagecache -- as those are returned to the free page pool, freeing a few pages from pagecache will return us to state (1) -- if however someone consumes these free pages quickly, we'll continue freeing up pages from the pagecache until we reach pagecache_limit_mb.
(3) Once we are at or below the low watermark, pagecache_limit_mb, the pages in the page cache will be governed by normal paging memory management decisions; if it starts growing above the limit (corrected by the free pages), we'll free some up again.

This feature is useful for machines that have large workloads, carefully sized to eat most of the memory. Depending on the applications page access pattern, the kernel may too easily swap the application memory out in favor of pagecache. This can happen even for low values of swappiness. With this feature, the admin can tell the kernel that only a certain amount of pagecache is really considered useful and that it otherwise should favor the applications memory.


Foreground vs. background shrinking:
-----------------------------------

Usually, the Linux kernel reclaims its memory using the kernel thread kswapd. It reclaims memory in the background. If it can't reclaim memory fast enough, it retries with higher priority and if this still doesn't succeed it uses a direct reclaim path.

For keeping the pagecache below the limit, we mostly rely on the background (kswapd) functionality; workloads that allocate pagecache or memory very quickly might thus temporarily have a higher amount of page cache than they should according to this logic.
